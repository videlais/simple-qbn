
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>Deck Building Â· HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 3.6.16">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="storygates.html" />
    
    
    <link rel="prev" href="../State.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">History of Related Terms</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../sculpturalmodel.html">
            
                <a href="../sculpturalmodel.html">
            
                    
                    Sculptural Hypertext Model
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="../Storylet.html">
            
                <a href="../Storylet.html">
            
                    
                    Storylet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="../qbn.html">
            
                <a href="../qbn.html">
            
                    
                    Quality-Based Narrative
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Metaphors in SimpleQBN</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../expressions.html">
            
                <a href="../expressions.html">
            
                    
                    Expression and QualitySet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="../cards.html">
            
                <a href="../cards.html">
            
                    
                    Deck and Cards
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="../State.html">
            
                <a href="../State.html">
            
                    
                    State Management
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Examples</li>
        
        
    
        <li class="chapter active" data-level="4.1" data-path="deckbuilding.html">
            
                <a href="deckbuilding.html">
            
                    
                    Deck Building
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2" data-path="storygates.html">
            
                <a href="storygates.html">
            
                    
                    Story Gates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.3" data-path="webbuild.html">
            
                <a href="webbuild.html">
            
                    
                    Bundled for Web
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Deck Building</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="deck-building">Deck Building</h1>
<h2 id="understanding-the-api">Understanding the API</h2>
<p>One of the most common first tasks with QBN projects is building a deck of cards. In SimpleQBN, this starts with the <strong>Deck</strong> class.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> Deck();
</code></pre>
<p>Creating a <strong>Deck</strong> also creates an internal <strong>State</strong> as its <em>state</em> property. The <strong>State</strong> API has the methods <em>add()</em>, <em>get()</em>, <em>has()</em>, <em>update()</em>, and <em>remove()</em>, which it uses to manipulate data stored as key-value pairs. Commonly, a String key is paired with a numeric value.</p>
<blockquote>
<p><strong>Note:</strong> Because of how <strong>Expressions</strong> are currently handled, it is strongly recommended to only use numeric or String values as part of the <strong>State</strong>. Boolean values do not work well, and decimal numbers do not work at all.</p>
</blockquote>
<pre><code class="lang-javascript"><span class="hljs-comment">// Create a new Deck</span>
<span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> Deck();
<span class="hljs-comment">// Add a key-value pair</span>
d.state.add(<span class="hljs-string">&apos;test&apos;</span>, <span class="hljs-number">1</span>);
</code></pre>
<p>The method <em>addCard()</em> of <strong>Deck</strong> accepts a String (<em>content</em>) and array (<em>qualities</em>) of a new <strong>Card</strong>. Internally, a <strong>Card</strong> will also create a unique <em>hash</em> as well.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Create a new Deck</span>
<span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> Deck();
<span class="hljs-comment">// Add a key-value pair</span>
d.state.add(<span class="hljs-string">&apos;test&apos;</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// Create a card</span>
d.addCard(<span class="hljs-string">&quot;Content&quot;</span>);
</code></pre>
<p>In quality-based narratives, a <em>quality</em> defines if content can be accessed. They are written as conditional statements. In SimpleQBN, these are created using hyphens between operators (things being compared) and the operation (how the values should be compared).</p>
<p>For example, to test if a key, &apos;test&apos;, is equal to a numeric value, 1, it would be written as <code>test-eq-1</code>. These are known as <strong>Expressions</strong>.</p>
<p>Qualities can be passed as either an array when using <em>addCard()</em> (of <strong>Deck</strong>) or with the <strong>Card</strong> method <em>addQuality()</em>. In either usage, qualities are expressed as String values. These then become part of a collection called a <strong>QualitySet</strong> internally in a <strong>Card</strong>. (Qualities are converted into individual <strong>Expressions</strong> internally as part of a <strong>QualitySet</strong>.)</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Create a new Deck</span>
<span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> Deck();
<span class="hljs-comment">// Add a key-value pair</span>
d.state.add(<span class="hljs-string">&apos;test&apos;</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// Create a card</span>
<span class="hljs-comment">// content - &quot;Content&quot;</span>
<span class="hljs-comment">// qualities - [&apos;test-eq-1&apos;]</span>
d.addCard(<span class="hljs-string">&quot;Content&quot;</span>, [<span class="hljs-string">&apos;test-eq-1&apos;</span>]);
</code></pre>
<p>Cards are selected through the metaphor of <em>drawing</em>. A <strong>Card</strong> is drawn when it is available; a <strong>Card</strong> is available when all of the <strong>Expressions</strong> within its <strong>QualitySet</strong> are valid. The <strong>State</strong> of the <strong>Deck</strong> is used to determine this validity. For example, if the <strong>State</strong> contains a key-value pair of <code>&apos;test&apos;:1</code>, then any <strong>Cards</strong> with the quality <code>test-eq-1</code> are potentially valid.</p>
<p>The method <em>draw()</em> of <strong>Deck</strong> returns an array of results matching an argument up to the <em>size</em> passed to it. However, only a <strong>Card</strong> that is available can be drawn.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Create a new Deck</span>
<span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> Deck();
<span class="hljs-comment">// Add a key-value pair</span>
d.state.add(<span class="hljs-string">&apos;test&apos;</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// Create a card</span>
<span class="hljs-comment">// content - &quot;Content&quot;</span>
<span class="hljs-comment">// qualities - [&apos;test-eq-1&apos;]</span>
d.addCard(<span class="hljs-string">&quot;Content&quot;</span>, [<span class="hljs-string">&apos;test-eq-1&apos;</span>]);
<span class="hljs-comment">// Draw the card from the deck</span>
<span class="hljs-keyword">const</span> hand = d.draw(<span class="hljs-number">1</span>);
<span class="hljs-comment">// Show the content of the first (and only) drawn card</span>
<span class="hljs-built_in">console</span>.log(hand[<span class="hljs-number">0</span>].content);
</code></pre>
<h2 id="adding-shuffling-and-re-drawing-cards">Adding, Shuffling, and Re-Drawing Cards</h2>
<p>Once a <strong>Deck</strong> is created, any number of additional <strong>Cards</strong> can be added. Based on their qualities, a <strong>Card</strong> can initially be available or become it through altering the <strong>State</strong> of the <strong>Deck</strong>. Alternatively, once a <strong>Card</strong> is drawn from a <strong>Deck</strong>, it can be updated in the <strong>Deck</strong> using the method <em>updateCard()</em> (passing the <strong>Card</strong> to the method). Additional qualities can be added to a <strong>Card</strong> and then updated in the deck in this way.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Create a new Deck</span>
<span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> Deck();
<span class="hljs-comment">// Add a key-value pair</span>
d.state.add(<span class="hljs-string">&apos;test&apos;</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// Create a card</span>
d.addCard(<span class="hljs-string">&quot;Content&quot;</span>, [<span class="hljs-string">&apos;test-eq-1&apos;</span>]);
<span class="hljs-comment">// Create another</span>
d.addCard(<span class="hljs-string">&quot;More Content&quot;</span>, [<span class="hljs-string">&apos;test-eq-1&apos;</span>]);
<span class="hljs-comment">// Create a third</span>
d.addCard(<span class="hljs-string">&quot;Even More Content&quot;</span>, [<span class="hljs-string">&apos;test-eq-1&apos;</span>]);
</code></pre>
<p>The method <em>shuffle()</em> randomly distributes existing cards within the <strong>Deck</strong>. Because all <strong>Cards</strong> are added in sequence, this method can be used to re-sort the <strong>Cards</strong> in the <strong>Deck</strong>.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Create a new Deck</span>
<span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> Deck();
<span class="hljs-comment">// Add a key-value pair</span>
d.state.add(<span class="hljs-string">&apos;test&apos;</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// Create a card</span>
d.addCard(<span class="hljs-string">&quot;Content&quot;</span>, [<span class="hljs-string">&apos;test-eq-1&apos;</span>]);
<span class="hljs-comment">// Create another</span>
d.addCard(<span class="hljs-string">&quot;More Content&quot;</span>, [<span class="hljs-string">&apos;test-eq-1&apos;</span>]);
<span class="hljs-comment">// Create a third</span>
d.addCard(<span class="hljs-string">&quot;Even More Content&quot;</span>, [<span class="hljs-string">&apos;test-eq-1&apos;</span>]);
<span class="hljs-comment">// Shuffle the cards</span>
d.shuffle();
</code></pre>
<p>The method <em>draw()</em> creates a new array. It does not alter the original <strong>Deck</strong> and its <strong>Cards</strong>. This means <strong>Cards</strong> can be drawn, manipulated, and then re-drawn again (assuming their qualities allow it).</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Create a new Deck</span>
<span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> Deck();
<span class="hljs-comment">// Add a key-value pair</span>
d.state.add(<span class="hljs-string">&apos;test&apos;</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// Create a card</span>
d.addCard(<span class="hljs-string">&quot;Content&quot;</span>, [<span class="hljs-string">&apos;test-eq-1&apos;</span>]);
<span class="hljs-comment">// Create another</span>
d.addCard(<span class="hljs-string">&quot;More Content&quot;</span>, [<span class="hljs-string">&apos;test-eq-1&apos;</span>]);
<span class="hljs-comment">// Create a third</span>
d.addCard(<span class="hljs-string">&quot;Even More Content&quot;</span>, [<span class="hljs-string">&apos;test-eq-1&apos;</span>]);
<span class="hljs-comment">// Shuffle the cards</span>
d.shuffle();
<span class="hljs-comment">// Draw all cards</span>
<span class="hljs-keyword">const</span> hand = draw(<span class="hljs-number">3</span>);
<span class="hljs-comment">// Get the first card in the drawn array</span>
<span class="hljs-keyword">const</span> c = hand[<span class="hljs-number">0</span>];
<span class="hljs-comment">// Add a new quality</span>
c.addQuality(<span class="hljs-string">&apos;example-eq-1&apos;</span>);
<span class="hljs-comment">// Update the deck</span>
d.updateCard(c);
<span class="hljs-comment">// Draw another array</span>
<span class="hljs-comment">// (However, only two cards will be available now.)</span>
<span class="hljs-keyword">const</span> anotherHand = draw(<span class="hljs-number">3</span>);
</code></pre>
<p>In the above code, the method <em>addQuality()</em> is used to add another quality to a card. As only the <strong>Card</strong> in the drawn collection would be updated, the <strong>Deck</strong> method <em>updateCard()</em> is also used. Through passing the <strong>Card</strong> to this method, it will update the internal <strong>Card</strong> where the unique <em>hash</em> of each match.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../State.html" class="navigation navigation-prev " aria-label="Previous page: State Management">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="storygates.html" class="navigation navigation-next " aria-label="Next page: Story Gates">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Deck Building","level":"4.1","depth":1,"next":{"title":"Story Gates","level":"4.2","depth":1,"path":"examples/storygates.md","ref":"./examples/storygates.md","articles":[]},"previous":{"title":"State Management","level":"3.3","depth":1,"path":"State.md","ref":"./State.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"root":"./notes","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"gitbook":"*"},"file":{"path":"examples/deckbuilding.md","mtime":"2021-01-30T06:12:30.671Z","type":"markdown"},"gitbook":{"version":"3.6.16","time":"2021-01-30T06:56:25.657Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

